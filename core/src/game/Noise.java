package game;

import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Vector2;

import java.util.Random;

/**
 * Two dimensional noise implementation based on Ken Perlin's
 * original implementation called "Perlin Noise".
 *
 * See {@link #noiseAt(float, float)} for algorithmic details.
 */
public class Noise {
    /** Describes possible noise parameters. */
    public static class Parameters {
        /** Number of octaves. The higher, the rougher. */
        public int octaves;
        /** Frequency. The higher, the noisier. */
        public float frequency;
        /** Persistence. The higher, the rougher. Should stay between zero and one. */
        public float persistence;

        /**
         * Constructs new instance with all values.
         *
         * @param octaves number of octaves
         * @param frequency frequency
         * @param persistence persistence
         */
        public Parameters(int octaves, float frequency, float persistence) {
            this.octaves = octaves;
            this.frequency = frequency;
            this.persistence = persistence;
        }
    }

    /** Holds gradient vectors used to generate noise, */
    public Vector2[][] gradients;

    /**
     * Constructs new instance and generates gradient vectors using given {@link Random}
     * random number generator.
     *
     * @param rand random number generator
     */
    public Noise(Random rand) {
        gradients = new Vector2[256][256];

        Vector2[] possible = new Vector2[] {
                new Vector2(1, 0),
                new Vector2(0, 1),
                new Vector2(-1, 0),
                new Vector2(0, -1)
        };

        for (int xx = 0; xx < gradients.length; xx++) {
            for (int yy = 0; yy < gradients[0].length; yy++) {
                gradients[xx][yy] = possible[rand.nextInt(possible.length - 1)];
            }
        }
    }

    /**
     * Returns combined noise value of given parameters at specified coordinates.
     *
     * Total noise value is calculated by layering each octave's noise value. Each value
     * is multiplied by the amplitude starting at one.
     *
     * For each successive octaves the amplitude is halved and the frequency doubled, which creates
     * the typical noise pattern.
     *
     * @param x x coordinate
     * @param y y coordinate
     * @param params noise parameters
     * @return combined noise value
     */
    public float noiseAt(float x, float y, Parameters params) {
        float val = 0;
        float total = 0;

        float freq = params.frequency;
        float amp = 1;

        for (int i = 0; i < params.octaves; i++) {
            val += noiseAt(x * freq, y * freq) * amp;
            total += amp;

            freq *= 2;

            amp *= .5f;
            amp *= params.persistence;
        }

        return MathUtils.clamp(val / total, 0, 1);
    }

    /**
     * Returns base noise value for given coordinates.
     *
     * To calculate the noise value, first the dot product of each corner cell's
     * gradient vector, generated by {@link #Noise(Random)}, and the given coordinates
     * is calculated. The final noise value is the bilinear interpolation of each
     * dot product and the given coordinates.
     *
     * @param x x coordinate
     * @param y y coordinate
     * @return calculated noise value
     */
    private float noiseAt(float x, float y) {
        int x0 = MathUtils.floor(x);
        int y0 = MathUtils.floor(y);

        int x1 = x0 + 1;
        int y1 = y0 + 1;

        float wx = x - x0;
        float wy = y - y0;

        int gx0 = x0;
        while (gx0 < 0) {
            gx0 += gradients.length;
        }
        gx0 %= gradients.length;

        int gx1 = x1;
        while (gx1 < 0) {
            gx1 += gradients.length;
        }
        gx1 %= gradients.length;

        int gy0 = y0;
        while (gy0 < 0) {
            gy0 += gradients[0].length;
        }
        gy0 %= gradients[0].length;

        int gy1 = y1;
        while (gy1 < gradients[0].length) {
            gy1 += gradients[0].length;
        }
        gy1 %= gradients[0].length;

        float v1 = new Vector2(x, y).sub(x0, y0).dot(gradients[gx0][gy0]);
        float v2 = new Vector2(x, y).sub(x1, y0).dot(gradients[gx1][gy0]);

        float i1 = interpolate(v1, v2, wx);

        v1 = new Vector2(x, y).sub(x0, y1).dot(gradients[gx0][gy1]);
        v2 = new Vector2(x, y).sub(x1, y1).dot(gradients[gx1][gy1]);

        float i2 = interpolate(v1, v2, wx);

        return MathUtils.clamp(interpolate(i1, i2, wy) + 0.5f, 0, 1);
    }

    /**
     * Interpolates between two values. This was originally suggested by
     * Ken Perlin to improve noise continuity.
     *
     * @param from starting value
     * @param to end value
     * @param t interpolation position
     * @return interpolated value
     */
    public float interpolate(float from, float to, float t) {
        return from + (to - from) * (6 * t * t * t * t * t - 15 * t * t * t * t + 10 * t * t * t);
    }
}
